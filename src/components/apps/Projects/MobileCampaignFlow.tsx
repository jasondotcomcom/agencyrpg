import React, { useState, useRef, useCallback, useEffect } from 'react';
import type { Campaign } from '../../../types/campaign';
import { calculateTeamCost, formatBudget } from '../../../types/campaign';
import { useCampaignContext } from '../../../context/CampaignContext';
import { useChatContext } from '../../../context/ChatContext';
import { useAchievementContext } from '../../../context/AchievementContext';
import { useAIRevolutionContext } from '../../../context/AIRevolutionContext';
import { getRandomDirection, getRandomDirectionExcluding } from '../../../data/autoDirections';
import type { DirectionQuality } from '../../../data/autoDirections';
import { teamMembers } from '../../../data/team';
import styles from './MobileCampaignFlow.module.css';

interface MobileCampaignFlowProps {
  campaign: Campaign;
}

type ConceptingStep = 'brief' | 'team' | 'direction' | 'generate';
const CONCEPTING_STEPS: ConceptingStep[] = ['brief', 'team', 'direction', 'generate'];

export default function MobileCampaignFlow({ campaign }: MobileCampaignFlowProps): React.ReactElement {
  const {
    setConceptingTeam,
    setStrategicDirection,
    generateConcepts,
    isGeneratingConcepts,
  } = useCampaignContext();
  const { triggerCampaignEvent } = useChatContext();
  const { incrementCounter, unlockAchievement } = useAchievementContext();
  const { isRevolutionActive } = useAIRevolutionContext();

  const [currentStep, setCurrentStep] = useState<ConceptingStep>(() => {
    // Start on the right step based on what's already been done
    if (campaign.conceptingTeam && campaign.conceptingTeam.memberIds.length >= 2 && campaign.strategicDirection.trim()) {
      return 'generate';
    }
    if (campaign.conceptingTeam && campaign.conceptingTeam.memberIds.length >= 2) {
      return 'direction';
    }
    return 'brief';
  });

  const [selectedTeamIds, setSelectedTeamIds] = useState<string[]>(
    campaign.conceptingTeam?.memberIds || []
  );
  const [direction, setDirection] = useState(campaign.strategicDirection);
  const [autoGenerated, setAutoGenerated] = useState(false);
  const [autoQuality, setAutoQuality] = useState<DirectionQuality | null>(
    campaign.autoDirectionQuality ?? null
  );
  const [slideDirection, setSlideDirection] = useState<'left' | 'right'>('left');

  const containerRef = useRef<HTMLDivElement>(null);

  const currentStepIndex = CONCEPTING_STEPS.indexOf(currentStep);
  const conceptingCost = calculateTeamCost(selectedTeamIds.length);
  const productionBudget = campaign.clientBudget - conceptingCost;
  const canGenerate = selectedTeamIds.length >= 2 && selectedTeamIds.length <= 4 && direction.trim().length > 0;

  const goToStep = useCallback((step: ConceptingStep) => {
    const newIndex = CONCEPTING_STEPS.indexOf(step);
    const oldIndex = CONCEPTING_STEPS.indexOf(currentStep);
    setSlideDirection(newIndex > oldIndex ? 'left' : 'right');
    setCurrentStep(step);
  }, [currentStep]);

  const goNext = useCallback(() => {
    const nextIndex = currentStepIndex + 1;
    if (nextIndex < CONCEPTING_STEPS.length) {
      goToStep(CONCEPTING_STEPS[nextIndex]);
    }
  }, [currentStepIndex, goToStep]);

  const goBack = useCallback(() => {
    const prevIndex = currentStepIndex - 1;
    if (prevIndex >= 0) {
      goToStep(CONCEPTING_STEPS[prevIndex]);
    }
  }, [currentStepIndex, goToStep]);

  // Save team when advancing from team step
  const handleLockTeam = () => {
    setConceptingTeam(campaign.id, selectedTeamIds);
    goNext();
  };

  const handleDirectionChange = (value: string) => {
    setDirection(value);
    setAutoGenerated(false);
    setAutoQuality(null);
    setStrategicDirection(campaign.id, value, null);
  };

  const handleSurpriseMe = () => {
    const result = autoGenerated
      ? getRandomDirectionExcluding(direction)
      : getRandomDirection();
    setDirection(result.text);
    setAutoGenerated(true);
    setAutoQuality(result.quality);
    setStrategicDirection(campaign.id, result.text, result.quality);

    const count = incrementCounter('auto-direction-used');
    if (count >= 3) unlockAchievement('delegator');
    if (result.quality === 'bad') {
      incrementCounter('auto-direction-bad-seen');
    }
  };

  const handleSendDirection = () => {
    setStrategicDirection(campaign.id, direction, autoQuality);
    goNext();
  };

  const handleGenerate = async () => {
    if (!canGenerate) return;
    if (campaign.generatedConcepts.length > 0) {
      const newCount = incrementCounter(`regen-${campaign.id}`);
      if (newCount >= 3) unlockAchievement('perfectionist-concepts');
    }
    if (!autoGenerated && autoQuality === null) {
      const manualCount = incrementCounter('manual-direction-campaigns');
      if (manualCount >= 5) unlockAchievement('control-freak');
    }
    if (autoGenerated && autoQuality === 'bad') {
      unlockAchievement('chaos-goblin');
    }
    triggerCampaignEvent('CONCEPTING', {
      campaignName: campaign.campaignName,
      clientName: campaign.clientName,
      assignedTeamIds: selectedTeamIds,
    });
    await generateConcepts(campaign.id);
  };

  const toggleMember = (memberId: string) => {
    setSelectedTeamIds(prev => {
      if (prev.includes(memberId)) return prev.filter(id => id !== memberId);
      if (prev.length >= 4) return prev;
      return [...prev, memberId];
    });
  };

  // Touch swipe handling
  const touchStartX = useRef(0);
  const touchStartY = useRef(0);

  const handleTouchStart = (e: React.TouchEvent) => {
    touchStartX.current = e.touches[0].clientX;
    touchStartY.current = e.touches[0].clientY;
  };

  const handleTouchEnd = (e: React.TouchEvent) => {
    const dx = e.changedTouches[0].clientX - touchStartX.current;
    const dy = e.changedTouches[0].clientY - touchStartY.current;
    // Only swipe if horizontal movement > 60px and mostly horizontal
    if (Math.abs(dx) > 60 && Math.abs(dx) > Math.abs(dy) * 1.5) {
      if (dx < 0 && currentStepIndex < CONCEPTING_STEPS.length - 1) {
        // Swiped left ‚Äî go next (only if step requirements met)
        if (currentStep === 'brief') goNext();
        else if (currentStep === 'team' && selectedTeamIds.length >= 2) handleLockTeam();
        else if (currentStep === 'direction' && direction.trim()) handleSendDirection();
      } else if (dx > 0 && currentStepIndex > 0) {
        goBack();
      }
    }
  };

  // Scroll to top when step changes
  useEffect(() => {
    containerRef.current?.scrollTo({ top: 0 });
  }, [currentStep]);

  return (
    <div className={styles.flow}>
      {/* Progress dots */}
      <div className={styles.progressBar}>
        {CONCEPTING_STEPS.map((step, i) => (
          <button
            key={step}
            className={`${styles.dot} ${i === currentStepIndex ? styles.active : ''} ${i < currentStepIndex ? styles.completed : ''}`}
            onClick={() => {
              if (i <= currentStepIndex) goToStep(step);
            }}
            aria-label={step}
          />
        ))}
      </div>

      {/* Card container */}
      <div
        ref={containerRef}
        className={styles.cardContainer}
        onTouchStart={handleTouchStart}
        onTouchEnd={handleTouchEnd}
      >
        <div className={`${styles.card} ${styles[`slide${slideDirection === 'left' ? 'Left' : 'Right'}`]}`} key={currentStep}>
          {/* STEP: Brief Overview */}
          {currentStep === 'brief' && (
            <div className={styles.cardContent}>
              <div className={styles.cardIcon}>üìã</div>
              <h2 className={styles.cardTitle}>{campaign.campaignName}</h2>
              <p className={styles.cardSubtitle}>{campaign.clientName}</p>

              <div className={styles.briefStats}>
                <div className={styles.briefStat}>
                  <span className={styles.briefStatLabel}>Budget</span>
                  <span className={styles.briefStatValue}>{formatBudget(campaign.clientBudget)}</span>
                </div>
                <div className={styles.briefStat}>
                  <span className={styles.briefStatLabel}>Timeline</span>
                  <span className={styles.briefStatValue}>{campaign.brief.timeline}</span>
                </div>
              </div>

              <div className={styles.briefChallenge}>
                <span className={styles.challengeLabel}>The Challenge</span>
                <p className={styles.challengeText}>{campaign.brief.challenge}</p>
              </div>

              <div className={styles.briefAudience}>
                <span className={styles.challengeLabel}>The Audience</span>
                <p className={styles.challengeText}>{campaign.brief.audience}</p>
              </div>

              <div className={styles.briefVibe}>
                <span className={styles.challengeLabel}>The Vibe</span>
                <p className={styles.challengeText}>{campaign.brief.vibe}</p>
              </div>
            </div>
          )}

          {/* STEP: Pick Team */}
          {currentStep === 'team' && (
            <div className={styles.cardContent}>
              <div className={styles.cardIcon}>üë•</div>
              <h2 className={styles.cardTitle}>Pick Your Team</h2>
              <p className={styles.cardSubtitle}>
                Select 2-4 people
                {selectedTeamIds.length > 0 && ` ‚Äî ${selectedTeamIds.length} selected`}
              </p>

              <div className={styles.teamGrid}>
                {teamMembers.map(member => {
                  const isSelected = selectedTeamIds.includes(member.id);
                  const atMax = !isSelected && selectedTeamIds.length >= 4;

                  return (
                    <button
                      key={member.id}
                      className={`${styles.teamMemberCard} ${isSelected ? styles.selected : ''} ${atMax ? styles.disabled : ''}`}
                      onClick={() => !atMax && toggleMember(member.id)}
                      disabled={atMax}
                    >
                      <span className={styles.memberAvatar}>{member.avatar}</span>
                      <span className={styles.memberName}>{member.name}</span>
                      <span className={styles.memberRole}>{member.role}</span>
                      {isSelected && <span className={styles.memberCheck}>‚úì</span>}
                    </button>
                  );
                })}
              </div>

              {selectedTeamIds.length > 0 && (
                <div className={styles.teamCostBar}>
                  Agency fee: {formatBudget(conceptingCost)}
                </div>
              )}
            </div>
          )}

          {/* STEP: Set Direction */}
          {currentStep === 'direction' && (
            <div className={styles.cardContent}>
              <div className={styles.cardIcon}>üéØ</div>
              <h2 className={styles.cardTitle}>Set the Direction</h2>
              <p className={styles.cardSubtitle}>
                Give your team a creative starting point
              </p>

              <textarea
                className={styles.directionInput}
                value={direction}
                onChange={(e) => handleDirectionChange(e.target.value)}
                placeholder="e.g., 'Go TikTok-native, show real overwhelm vs. calm' or 'Position as anti-AI-hype, focus on simplicity'"
                rows={4}
              />

              <button
                className={styles.surpriseButton}
                onClick={handleSurpriseMe}
                type="button"
              >
                {autoGenerated ? 'üîÑ Try Another' : '‚ú® Surprise Me'}
              </button>
              {autoGenerated && (
                <span className={styles.autoTag}>Auto-generated direction</span>
              )}
            </div>
          )}

          {/* STEP: Generate */}
          {currentStep === 'generate' && (
            <div className={styles.cardContent}>
              <div className={styles.cardIcon}>‚ú®</div>
              <h2 className={styles.cardTitle}>Ready to Generate</h2>
              <p className={styles.cardSubtitle}>
                Your team will brainstorm campaign concepts
              </p>

              <div className={styles.generateSummary}>
                <div className={styles.summaryRow}>
                  <span className={styles.summaryLabel}>Team</span>
                  <span className={styles.summaryValue}>
                    {selectedTeamIds.map(id => {
                      const m = teamMembers.find(t => t.id === id);
                      return m ? `${m.avatar} ${m.name}` : id;
                    }).join(', ')}
                  </span>
                </div>
                <div className={styles.summaryRow}>
                  <span className={styles.summaryLabel}>Direction</span>
                  <span className={styles.summaryValue}>{direction}</span>
                </div>
                <div className={styles.summaryDivider} />
                <div className={styles.summaryRow}>
                  <span className={styles.summaryLabel}>Client Budget</span>
                  <span className={styles.summaryValue}>{formatBudget(campaign.clientBudget)}</span>
                </div>
                <div className={styles.summaryRow}>
                  <span className={styles.summaryLabel}>Your Fee</span>
                  <span className={styles.summaryValue}>-{formatBudget(conceptingCost)}</span>
                </div>
                <div className={styles.summaryRow}>
                  <span className={styles.summaryLabel}>Production Budget</span>
                  <span className={`${styles.summaryValue} ${styles.summaryHighlight}`}>{formatBudget(productionBudget)}</span>
                </div>
                {productionBudget < campaign.clientBudget * 0.3 && (
                  <div className={styles.budgetWarning}>
                    Large team fee leaves tight production budget
                  </div>
                )}
              </div>

              {isGeneratingConcepts && (
                <div className={styles.generatingState}>
                  <span className={styles.generatingSpinner}>‚ú®</span>
                  <span>Team is brainstorming...</span>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      {/* Bottom navigation */}
      <div className={styles.bottomNav}>
        {currentStepIndex > 0 && (
          <button className={styles.backButton} onClick={goBack}>
            Back
          </button>
        )}

        <div className={styles.navSpacer} />

        {currentStep === 'brief' && (
          <button className={styles.ctaButton} onClick={goNext}>
            Choose Your Team ‚Üí
          </button>
        )}

        {currentStep === 'team' && (
          <button
            className={`${styles.ctaButton} ${selectedTeamIds.length < 2 ? styles.ctaDisabled : ''}`}
            onClick={handleLockTeam}
            disabled={selectedTeamIds.length < 2}
          >
            {selectedTeamIds.length < 2
              ? `Select ${2 - selectedTeamIds.length} more`
              : 'Lock Team ‚Üí'}
          </button>
        )}

        {currentStep === 'direction' && (
          <button
            className={`${styles.ctaButton} ${!direction.trim() ? styles.ctaDisabled : ''}`}
            onClick={handleSendDirection}
            disabled={!direction.trim()}
          >
            {direction.trim() ? 'Send to Team ‚Üí' : 'Enter a direction'}
          </button>
        )}

        {currentStep === 'generate' && (
          isRevolutionActive ? (
            <div className={styles.revolutionMessage}>
              üè¥‚Äç‚ò†Ô∏è Team refuses to work
            </div>
          ) : (
            <button
              className={`${styles.ctaButton} ${!canGenerate || isGeneratingConcepts ? styles.ctaDisabled : ''}`}
              onClick={handleGenerate}
              disabled={!canGenerate || isGeneratingConcepts}
            >
              {isGeneratingConcepts ? '‚è≥ Brainstorming...' : '‚ú® Generate Concepts'}
            </button>
          )
        )}
      </div>
    </div>
  );
}
